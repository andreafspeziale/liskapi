FORMAT: 0.1.0
# Lisk APIs Wrapper

## Group Introduction
This library aims to make **[LISK APIs](https://lisk.io/documentation?i=lisk-docs/APIReference)** easy/smart to use.

Note: **[Lisk](https://lisk.io/)** is a blockchain application platform and crypto-currency, which offers an all round solution for Node.js and JavaScript developers to deploy their own blockchain applications.

The library smart handle all the **Lisk APIs call** with options like sorting and pagination. The dApps ones are not included at the moment.

# Installation
The library is available through the

+ npm package manager

        $ npm install liskapi

# Configuration
To performs the requests the library can use a local or remote Lisk node:

+ Require the lib using a local node

        const lisk = require ('liskapi')();

+ Require the lib using a remote node

        const params = {
            host: 'othernode.com',
            port: 8000,
            ssl: true
        };

        const lisk = require ('liskapi')(params);

## Group Accounts

API calls related to Account functionality.

## openAccount

Create a Lisk account.

+ Parameters

    + secret: "some secret sentence" (required, string)

+ Usage

        lisk.openAccount ()
            .data ({ secret: 'some secret sentence' })
            .call ()
            .then ((res) => {
                console.log (`Post for opening an account\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error opening an account\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "account": {
            "address": "Address of account. String",
            "unconfirmedBalance": "Unconfirmed balance of account. Integer",
            "balance": "Balance of account. Integer",
            "publicKey": "Public key of account. Hex",
            "unconfirmedSignature": "If account enabled second signature, but it's still not confirmed. Boolean: true or false",
            "secondSignature": "If account enabled second signature. Boolean: true or false",
            "secondPublicKey": "Second signature public key. Hex",
            "username": "Username of account."
          }
        }

## getBalance

Request the balance of an account by address.

+ Parameters

    + address: "some address" (string)

+ Usage

        lisk.getBalance ({ address: 'address' })
            .call ()
            .then ((res) => {
                console.log (`Get balance\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting balance\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "balance": "Balance of account",
          "unconfirmedBalance": "Unconfirmed balance of account"
        }

## getPublicKey

Get the public key of an account.

+ Parameters

    + address: "some address" (string)

+ Usage

        lisk.getPublicKey ({ address: 'address' })
            .call ()
            .then ((res) => {
                console.log (`Get public key\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting public key\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "publicKey": "Public key of account. Hex"
        }

## generatePublicKey

Returns the public key of the provided secret key.

+ Parameters

    + secret: "some secret sentence" (required, string)

+ Usage

        lisk.generatePublicKey ()
            .data ({ secret: 'some secret sentence' })
            .call ()
            .then ((res) => {
                console.log (`Post for generating a publicKey\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error generating a publicKey\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "publicKey": "Public key of account. Hex"
        }

## getAccount

Returns account information of an address.

+ Parameters

    + address: "some address" (string)

+ Usage

        lisk.getAccount ({ address: 'address' })
            .call ()
            .then ((res) => {
                console.log (`Getting an account\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error getting an account\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "account": {
            "address": "Address of account. String",
            "unconfirmedBalance": "Unconfirmed balance of account. Integer",
            "balance": "Balance of account. Integer",
            "publicKey": "Public key of account. Hex",
            "unconfirmedSignature": "If account enabled second signature, but it's still not confirmed. Boolean: true or false",
            "secondSignature": "If account enabled second signature. Boolean: true or false",
            "multisignatures": "Array"
            "u_multisignatures": "Array"
          }
        }

## getDelegatesByAddress

Returns delegate accounts by address.

+ Parameters

    + address: "some address" (string)

+ Usage

        lisk.getDelegatesByAddress ({ address: 'address' })
            .call ()
            .then ((res) => {
                console.log (`Get delegates by address\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting delegates by address\n', err);
            });

+ Response 200 (application/json)

        {
            "success": true,
            "delegates": [array]
        }

## voteDelegates

Add or remove votes to a delegate by address.

+ Parameters

    + secret: "some address" (required, string)

    + publicKey "address public key" (required, string)

    + secondSecret "second address secret" (string)

    + "delegates" : "Array of string in the following format: ["+DelegatePublicKey"] OR ["-DelegatePublicKey"]. Use + to UPvote, - to DOWNvote" (required, array)

+ Usage

        lisk.voteDelegates ()
            .data ({ secret: 'some secret',
                    publicKey: 'public key',
                    delegates:["+AddVoteToSomePublicKey", "-AddVoteToSomePublicKey"]
            })
            .call ()
            .then ((res) => {
                console.log (`Put for voting delegates\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error voting delegates\n', err);
            });

+ Response 200 (application/json)

        {
            "success": true,
            "transaction": {object}
        }


## Group Loader

Provides the synchronization and loading information of a client. These API calls will only work if the client is syncing or loading.

## getLoadingStatus

Returns the status of the blockchain.

+ Usage

        lisk.getLoadingStatus ().call ()
            .then ((res) => {
                console.log (`Get loading status\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error', err);
            });

+ Response 200 (application/json)

        {
           "success": true,
           "loaded": "Is blockchain loaded? Boolean: true or false",
           "now": "Last block loaded during loading time. Integer",
           "blocksCount": "Total blocks count in blockchain at loading time. Integer"
        }

## getSyncStatus

Get the synchronization status of the client.

+ Usage

        lisk.getSyncStatus ().call ()
            .then ((res) => {
                console.log (`Get sync status data\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error', err);
            });

+ Response 200 (application/json)

        {
           "success": true,
           "syncing": "Is wallet is syncing with another peers? Boolean: true or false",
           "blocks": "Number of blocks remaining to sync. Integer",
           "height": "Total blocks in blockchain. Integer",
           "broadhash": "Broadhash. String",
           "consensus": "Consensus. Integer"
        }

## getBlockReceiptStatus

Get the status of last received block. Returns true if block was received in the past 120 seconds.

+ Usage

        lisk.getBlockReceiptStatus ().call ()
            .then ((res) => {
                console.log (`Get receipt status data\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error', err);
            });

+ Response 200 (application/json)

        {
           "success": true
        }

## Group Transactions

API calls related to transactions.

## getTransactions

List of transactions matched by provided parameters.

+ Parameters

    + blockId: "some block id" (string)
    + senderId: "sender address" (string)
    + recipientId: "recipient of transaction" (string)
    + limit: "limit of transaction to send in response" (default 20, number)
    + offset: "offset to load" (number)

+ Options

    + pagination (limit and offset)
    + sorting

+ Usage

        lisk.getTransactions ()
           .paginate ({ blockId: 'some id', limit: 100, offset: 0 })
           .call ()
           .then ((res) => {
               console.log (`Get TXs data with pagination options\n ${JSON.stringify (res)`);
           })
           .catch ((err) => {
               console.log ('Got an error getting TXs', err);
           });

+ Response 200 (application/json)

        {
          "success": true,
          "transactions": [
            "list of transactions objects"
          ]
        }

## sendTransaction

Send transaction to broadcast network.

+ Parameters

    + secret: "some secret sentence" (required, string)
    + amount: "amount of tx" (required, number)
    + recipientId: "recipient of transaction" (required, string)
    + publicKey: "public key of sender account" (required, string)
    + secondSecret: "required if user uses second signature" (string)

+ Usage

        lisk.sendTransaction ()
            .data ({ secret: 'some secret',
                amount: 20,
                recipientId: 'address',
                publicKey: 'publicKey'
            })
            .call ()
            .then ((res) => {
                console.log (`Put for sending LSK\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error sending LSK\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "transactionId": "id of added transaction"
        }

## getTransaction

Get transaction that matches the provided id.

+ Parameters

    + id: "tx id" (string)

+ Usage

        lisk.getTransaction ({id: 'tx id'})
            .call ()
            .then ((res) => {
                console.log (`Get tx data\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting tx data\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "transaction": {
            "id": "Id of transaction. String",
            "height": "Tx blockchain height. Integer",
            "blockId" "Tx blockId. String",
            "type": "Type of transaction. Integer",
            "timestamp": "Timestamp of transaction. Integer",
            "senderPublicKey": "Sender public key of transaction. Hex",
            "senderId": "Address of transaction sender. String",
            "recipientId": "Recipient id of transaction. String",
            "amount": "Amount. Integer",
            "fee": "Fee. Integer",
            "signature": "Signature. Hex",
            "signatures": "Signatures. Array",
            "confirmations": "Number of confirmations. Integer",
            "asset": "Resources. Object"
          }
        }

## getUnconfirmedTransaction

Get unconfirmed transaction that matches the provided id.

+ Parameters

      + id: "unConfirmedTx id" (string)

+ Usage

        lisk.getUnconfirmedTransaction ({id: 'unConfirmedTx'})
            .call ()
            .then ((res) => {
                console.log (`Get unConfirmedTx data\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting unConfirmedTx data\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "transaction": {
            "type": "Type of transaction. Integer",
            "amount": "Amount. Integer",
            "senderPublicKey": "Sender public key of transaction. Hex",
            "timestamp": "Timestamp of transaction. Integer",
            "asset": "Resources. Object"
            "recipientId": "Recipient id of transaction. String",
            "signature": "Signature. Hex",
            "id": "Id of transaction. String",
            "fee": "Fee. Integer",
            "senderId": "Address of transaction sender. String",
            "relays": "Propagation. Integer",
            "receivedAt": "Timestamp. String"
          }
        }

## getUnconfirmedTransactions

Gets a list of unconfirmed transactions.

+ Usage

        lisk.getUnconfirmedTransactions ()
            .call ()
            .then ((res) => {
                console.log (`Get unConfirmedTxS data\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting unConfirmedTxS data\n', err);
            });

+ Response 200 (application/json)

        {
            "success" : true,
            "transactions" : [list of transaction objects]
        }

## getQueuedTransactions

Gets a list of queued transactions.

+ Usage

        lisk.getQueuedTransactions ()
            .call ()
            .then ((res) => {
                console.log (`Get queuedTxS data\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting queuedTxS data\n', err);
            });

+ Response 200 (application/json)

        {
            "success" : true,
            "transactions" : [list of transaction objects]
        }

## getQueuedTransaction

Get queued transaction that matches the provided id.

+ Parameters

      + id: "queuedTx id" (string)

+ Usage

        lisk.getQueuedTransaction ()
            .call ()
            .then ((res) => {
                console.log (`Get queuedTx data\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting queuedTx data\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "transaction": {
            "id": "Id of transaction. String",
            "type": "Type of transaction. Integer",
            "subtype": "Subtype of transaction. Integer",
            "timestamp": "Timestamp of transaction. Integer",
            "senderPublicKey": "Sender public key of transaction. Hex",
            "senderId": "Address of transaction sender. String",
            "recipientId": "Recipient id of transaction. String",
            "amount": "Amount. Integer",
            "fee": "Fee. Integer",
            "signature": "Signature. Hex",
            "signSignature": "Second signature. Hex",
            "confirmations": "Number of confirmations. Integer"
          }
        }

## Group Peers

Peers API.

## getPeersList

Gets list of peers from provided filter parameters.

+ Parameters

      + state: "state of peer. 1 - disconnected. 2 - connected. 0 - banned." (number)
      + os: "peer operating system" (string)
      + version: "peer version" (string)

+ Options

    + pagination (limit and offset)
    + sorting

+ Usage

        lisk.getPeersList ( { state: 1 } )
            .paginate ({ limit: 10, offset: 5 })
            .call ()
            .then ((res) => {
                console.log (`Get peers of Liskword\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting peers\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "peers": [
            "list of peers as objects (see below the peer object response)"
          ]
        }


## getPeer

Gets peer by IP address and port.

+ Parameters

      + ip: "host IP" (string)
      + port: "host port used for the Lisk application" (number)

+ Usage

        lisk.getPeer ({ip: 'IP', port: port})
            .call ()
            .then ((res) => {
                console.log (`Get peer by IP\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting peer\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "peer": {
                "ip":"requested ip. String",
                "port":"requested port. Integer",
                "state":"1 - disconnected. 2 - connected. 0 - banned. Integer",
                "os":"operating system. String",
                "version":"Lisk client version. String",
                "broadhash":"peer block propagation efficiency and reliability. String",
                "height":"blockchain height. Integer"
          }
        }

## getPeerVersion

Gets a list peer versions and build times.

+ Usage

        lisk.getPeerVersion ()
            .call ()
            .then ((res) => {
                console.log (`Get peer version\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting peer version\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "version": "version of Lisk. String",
          "build": "time of build. String"
        }

## Group Blocks

Blocks management API.

## getBlock

Gets block by provided id.

+ Parameters

      + id: "block id" (string)

+ Usage

        lisk.getBlock ({id:'10278032324520856952'})
            .call ()
            .then ((res) => {
                console.log (`Get block by id\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting block by id\n', err);
            });

+ Response 200 (application/json)

        {
            "success": true,
            "block": {
                "id": "Id of block. String",
                "version": "Version of block. Integer",
                "timestamp": "Timestamp of block. Integer",
                "height": "Height of block. Integer",
                "previousBlock": "Previous block id. String",
                "numberOfTransactions": "Number of transactions. Integer",
                "totalAmount": "Total amount of block. Integer",
                "totalFee": "Total fee of block. Integer",
                "reward": "Reward block. Integer",
                "payloadLength": "Payload length of block. Integer",
                "payloadHash": "Payload hash of block. Integer",
                "generatorPublicKey": "Generator public key. Hex",
                "generatorId": "Generator id. String.",
                "blockSignature": "Block signature. Hex",
                "confirmations": "Block confirmations. Integer",
                "totalForged": "Total block forged. Integer"
            }
        }

## getBlocks

Gets all blocks by provided filter(s).

+ Parameters

      + generatorPublicKey: "generator block id" (string)
      + height: "height of block" (number)
      + previousBlock: "previous block" (string)
      + totalAmount: "total block amount" (number)
      + totalFee: "total block fee" (number)

+ Options

    + pagination (limit and offset)
    + sorting

+ Usage

        lisk.getBlocks ()
            .paginate ({ limit: 2, offset: 0 })
            .sort ({ height: 'asc' })
            .call ()
            .then ((res) => {
                console.log (`Get blocks sorted and paginated\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting blocks sorted and paginated\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "blocks": [
            "array of blocks (see above block object response)"
          ]
        }

## getFee

Get transaction fee for sending "normal" transactions.

+ Usage

        lisk.getFee ()
            .call ()
            .then ((res) => {
                console.log (`Get blockchain fee\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting blockchain fee\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "fee": Integer
        }

## getFees

Get transaction fee for all types of transactions.

+ Usage

        lisk.getFees ()
            .call ()
            .then ((res) => {
                console.log (`Get blockchain fees schedule\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting blockchain fees schedule\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "fees":{
            "send": Integer,
            "vote": Integer,
            "secondsignature": Integer,
            "delegate": Integer,
            "multisignature": Integer,
            "dapp": Integer
          }
        }
        
## getReward

Gets the forging reward for blocks.

+ Usage

        lisk.getReward ()
            .call ()
            .then ((res) => {
                console.log (`Get blockchain reward schedule\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting blockchain reward schedule\n', err);
            });

+ Response 200 (application/json)

        {
          "success": true,
          "reward": Integer
        }
        
## getSupply

Gets the total amount of Lisk in circulation.

+ Usage

        lisk.getSupply ()
            .call ()
            .then ((res) => {
                console.log (`Get supply\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting supply\n', err);
            });
            
+ Response 200 (application/json)
            
            {
              "success": true,
              "supply": Integer
            }
            
## getHeight

Gets the blockchain height of the client.

+ Usage
 
        lisk.getHeight ()
            .call ()
            .then ((res) => {
                console.log (`Get height\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting height\n', err);
            });
            
+ Response 200 (application/json)

        {
          "success": true,
          "height": "Height of blockchain. Integer"
        }

## getStatus

Gets status of height, fee, milestone, blockreward and supply.

+ Usage

        lisk.getStatus ()
            .call ()
            .then ((res) => {
                console.log (`Get status\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting status\n', err);
            });
            
+ Response 200 (application/json)

        {
          "success": true,
          "height": Integer
          "fee": Integer
          "milestone": Integer
          "reward": Integer
          "supply": Integer
        }
        
## getNethash

Gets the nethash of the blockchain on a client.

+ Usage 

        lisk.getNethash ()
            .call ()
            .then ((res) => {
                console.log (`Get nethash\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting nethash\n', err);
            });
            
+ Response 200 (application/json)

        {
          "success": true,
          "nethash": "Nethash of the Blockchain. String"
        }
        
## getMilestone

Gets the milestone of the blockchain on a client.

+ Usage

        lisk.getMilestone ()
            .call ()
            .then ((res) => {
                console.log (`Get milestone\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting milestone\n', err);
            });
            
+ Response 200 (application/json)

        {
          "success": true,
          "milestone": Integer
        }
        
## Group Signatures

Signature management API.

## getSignatureFee

Gets the second signature status of an account.

+ Usage

        lisk.getSignatureFee ()
            .call ()
            .then ((res) => {
                console.log (`Get signature fee\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error in getting signature fee\n', err);
            });        

+ Response 200 (application/json)

        {
          "success" : true,
          "fee" : Integer
        }
        
## addSecondSignature

Add a second signature to an account.

+ Parameters

    + secret: "some address" (required, string)

    + secondSecret "second address secret" (string)

    + publicKey "address public key" (string)
        
+ Usage

        lisk.addSecondSignature ()
            .data ({ secret: 'novel clinic describe crane tissue glory very cage ranch nasty erosion subject',
                secondSecret: 'correct crisp theory price notable skin quote inspire lock dice divide curve'
            })
            .call ()
            .then ((res) => {
                console.log (`Put for adding second signature\n ${JSON.stringify (res)}`);
            })
            .catch ((err) => {
                console.log ('Got an error adding second signature\n', err);
            });
            
+ Response 200 (application/json)

        {  
                   "success":true,
                   "transaction":{  
                      "type": Integer,
                      "amount": Integer,
                      "senderPublicKey": "Sender public key. String",
                      "requesterPublicKey": "Requester public key. String",
                      "timestamp": Integer,
                      "asset":{  
                         "signature":{  
                            "publicKey":"Public key. String"
                         }
                      },
                      "recipientId":"Recipient address. String",
                      "signature":"Signature. String",
                      "id":"Tx ID. String",
                      "fee":"Fee Integer",
                      "senderId":"Sender address. String",
                      "relays":Integer,
                      "receivedAt":"Time. String"
                   }
                }
        }

## Group Delegates

Delegates API.

<!--

## Group Delegates
## Group Multi-Signature
-->
